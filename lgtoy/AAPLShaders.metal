/*
Abstract:
Metal shaders used for this sample
*/

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

// Include header shared between this Metal shader code and C code executing Metal API commands
#import "AAPLShaderTypes.h"

// Vertex shader outputs and per-fragment inputs. Includes clip-space position and vertex outputs
//  interpolated by rasterizer and fed to each fragment generated by clip-space primitives.
typedef struct
{
    // The [[position]] attribute qualifier of this member indicates this value is the clip space
    //   position of the vertex wen this structure is returned from the vertex shader
    float4 clipSpacePosition [[position]];
} RasterizerData;

// Vertex Function
vertex RasterizerData vertexShader(uint vertexID [[ vertex_id ]]) {
    const float2 verts[4] = {
        { -1.0,  -1.0},
        { -1.0,   1.0},
        {  1.0,  -1.0},
        {  1.0,   1.0}
    };
    RasterizerData out;
    out.clipSpacePosition.xy = verts[vertexID];
    out.clipSpacePosition.z = 0.0;
    out.clipSpacePosition.w = 1.0;
    return out;
}

#if 0

float3 hsv2rgb(float3 c) {
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}


float opUnion( float d1, float d2 ) {  return min(d1,d2); }
float opSubtraction( float d1, float d2 ) { return max(-d1,d2); }

float sdfCube(float3 p, float3 s) {
    float3 d = abs(p) - s;
    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));
}

float sdfSphere(float3 p, float s ) {
    return length(p)-s;
}

float map(float3 p){
    const float a = 2560.0/1600.0;
    
    
    return opUnion(opUnion(opSubtraction(
                                 sdfCube(p+float3(0.0,0.0, 0.2), float3(a*1.0, 1.0, 0.2)),
                                 sdfCube(p+float3(0.0,0.0, 0.201), float3(20, 20,     0.2))),
                   sdfSphere(p+float3(-0.8, 0.,0.5), 0.5)),
                   sdfCube(p+float3(0.5, 0.0, 0.0), float3(0.3))
                   );
}

float3 normal(float3 p) {
    const float h = 0.0001;
    const float2 k = float2(1.0, -1.0);
    return normalize(k.xyy*map( p + k.xyy*h ) +
                     k.yyx*map( p + k.yyx*h ) +
                     k.yxy*map( p + k.yxy*h ) +
                     k.xxx*map( p + k.xxx*h ) );
}


float3 intersectWithWorld(float3 p, float3 dir){
    float dist = 0.0;
    float nearest = 0.0;
    float3 col = float3(0.0);
    for(int i = 0; i < 40; i++){
        nearest = map(p + dir*dist);
        if(nearest < 0.0001){
            float3 pos = p+dir*dist;
            float3 nor = normal(pos);
            
            pos *= 10;
            float3 pp = abs(fract(pos)-0.5);
            float w = min(1., 50*pp.x*pp.y*pp.z);
            pp = floor(pos-0.5);
            col = hsv2rgb(float3(cos(pp.x*11.3+pp.y*5.2+pp.z*9.7), 1, 1))*w;
            float d = clamp( dot( nor,normalize(float3(0.4,-0.3,1.0)) ), 0.0, 1.0 );
            col *= 0.1 + 0.9*d;
            col += pow(d, 16.0);
            break;
        }
        dist += nearest;
    }
    return col;
}




float3 quilt_map(float2 p, float a, float iTime) {
    a = fract(a);
    
    //a = floor(a*45)/45;

    float offset = -(a-0.5)*7.;
    
    float3 ro = float3( offset, 0.0, 5);
    float3 rd = normalize(float3(p.x-offset, p.y, -5 ) );
    return intersectWithWorld(ro, rd);
}

#else
// scene: plasma ball

// noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
float4 mod289(float4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
float4 perm(float4 x){return mod289(((x * 34.0) + 1.0) * x);}

float noise3(float3 p){
    float3 a = floor(p);
    float3 d = p - a;
    d = d * d * (3.0 - 2.0 * d);
    
    float4 b = a.xxyy + float4(0.0, 1.0, 0.0, 1.0);
    float4 k1 = perm(b.xyxy);
    float4 k2 = perm(k1.xyxy + b.zzww);
    
    float4 c = k2 + a.zzzz;
    float4 k3 = perm(c);
    float4 k4 = perm(c + 1.0);
    
    float4 o1 = fract(k3 * (1.0 / 41.0));
    float4 o2 = fract(k4 * (1.0 / 41.0));
    
    float4 o3 = o2 * d.z + o1 * (1.0 - d.z);
    float2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
    
    return o4.y * d.y + o4.x * (1.0 - d.y);
}


float hash(float n){return fract(sin(n) * 43758.5453123);}

float noise1(float p){
    float fl = floor(p);
    float fc = fract(p);
    return mix(hash(fl), hash(fl + 1.0), fc);
}

// based on https://www.shadertoy.com/view/XsjXRm
float2x2 mm2(float a){float c = cos(a), s = sin(a);return float2x2(c,-s,s,c);}

float sins(float x, float time) {
    float rz = 0.;
    float z = 2.;
    for (float i= 0.;i < 3.;i++ ) {
        rz += abs(fract(x*1.4)-0.5)/z;
        x *= 1.3;
        z *= 1.15;
        x -= time*.65*z;
    }
    return rz;
}

float segm(float3 p, float3 a, float3 b) {
    float3 pa = p - a;
    float3 ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );
    return length( pa - ba*h )*.5;
}

float3 path(float i, float d, float time) {
    float3 en = float3(0.,0.,1.);
    float sns2 = sins(d+i*0.5, time)*0.22;
    float sns = sins(d+i*.6, time)*0.21;
    en.xz = en.xz*mm2((hash(i*10.569)-.5)*6.2+sns2);
    en.xy = en.xy*mm2((hash(i*4.732)-.5)*6.2+sns);
    return en;
}

float2 map(float3 p, float i, float time) {
    float lp = length(p);
    float3 bg = float3(0.);
    float3 en = path(i,lp, time);
    
    float ins = smoothstep(0.11,.46,lp);
    float outs = .15+smoothstep(.0,.15,abs(lp-1.));
    p *= ins*outs;
    float id = ins*outs;
    
    float rz = segm(p, bg, en)-0.011;
    return float2(rz,id);
}

#define NUM_RAYS 8.

#define VOLUMETRIC_STEPS 3 /* was 19 */

#define MAX_ITER 35
#define FAR 6.

float march(float3 ro, float3 rd, float startf, float maxd, float j, float time) {
    const float precis = 0.001;
    float d = startf;
    for( int i=0; i<MAX_ITER; i++ ) {
        float h = map(ro+rd*d, j, time).x;
        if(abs(h)<precis || d>maxd ) break;
        d += h*1.2;
    }
    return d;
}

//volumetric marching
float3 vmarch(float3 ro, float3 rd, float j, float3 orig, float time) {
    float3 p = ro;
    float3 sum = float3(0);
    for( int i=0; i<VOLUMETRIC_STEPS; i++ ) {
        float2 r = map(p,j, time);
        p += rd*.03;
        float lp = length(p);
        
        float3 col = sin(float3(1.05,2.5,1.52)*3.94+r.y)*.85+0.4;
        col.rgb *= smoothstep(.0,.015,-r.x);
        col *= smoothstep(0.04,.2,abs(lp-1.1));
        col *= smoothstep(0.1,.34,lp);
        sum += abs(col)*5. * (1.2-noise1(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);
    }
    return sum;
}


float flow(float3 p, float t) {
    
    const float3x3 m3 = float3x3( 0.00,  0.80,  0.60,
                   -0.80,  0.36, -0.48,
                   -0.60, -0.48,  0.64 );
    
    float z=2.;
    float rz = 0.;
    float3 bp = p;
    for (float i= 1.;i < 5.;i++ ) {
        p += abs(t)*.1;
        rz+= (sin(noise3(p+t*0.8)*6.)*0.5+0.5) /z;
        p = mix(bp,p,0.6);
        z *= 2.;
        p *= 2.01;
        p*= m3;
    }
    return rz;
}


//returns both collision dists of unit sphere
float2 iSphere2(float3 ro, float3 rd) {
    float b = dot(ro, rd);
    float c = dot(ro,ro) - 1.;
    float h = b*b - c;
    if(h <0.0) return float2(-1.);
    else return float2((-b - sqrt(h)), (-b + sqrt(h)));
}


float3 quilt_map(float2 p, float a, float time) {
    a = fract(a);
    float offset = -(a-0.5)*7.;
    
    float3 ro = float3( offset, 0.0, 5);
    float3 rd = normalize(float3(p.x-offset, p.y, -5 ) );
    
    float3 col = float3(0.);

#if 1
    // streamers
    float3 bro = ro;
    float3 brd = rd;
    
    for (float j = 1.;j<NUM_RAYS+1.;j++) {
        ro = bro;
        rd = brd;
        float2x2 mm = mm2((time*0.2+((j+1.)*5.1))*j*0.25);
        ro.xy = ro.xy*mm;rd.xy = rd.xy*mm;
        ro.xz = ro.xz*mm;rd.xz = rd.xz*mm;
        float rz = march(ro,rd,2.5,FAR,j, time);
        if(rz >= FAR) continue;
        float3 pos = ro+rz*rd;
        col += vmarch(pos,rd,j, bro, time);
    }
    ro = bro;
    rd = brd;
#endif

    // sphere
    float2 sph = iSphere2(ro,rd);
    if (sph.x > 0.) {
        float3 pos = ro+rd*sph.x;
        float3 pos2 = ro+rd*sph.y;
        float3 rf = reflect( rd, pos );
        float3 rf2 = reflect( rd, pos2 );
        float nz = (-log(abs(flow(rf*1.2,time)-.01)));
        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));
        col += (0.1*nz*nz* float3(0.12,0.12,.5) + 0.05*nz2*nz2*float3(0.55,0.2,.55))*0.8;
    }
    
    return col*2; // brighten it up a bit
}

#endif

// Fragment function
fragment float4
samplingShader(RasterizerData in [[stage_in]],
               constant QuiltFragmentUniforms &uniforms  [[ buffer(QuiltFragmentInputIndexUniforms) ]])
{
    
    float a = dot(uniforms.calib.xy, in.clipSpacePosition.xy) + uniforms.calib.z;
    
    // normalize and fix aspect ratio
    float2 p = 2.0*in.clipSpacePosition.xy/uniforms.size - 1.0;
    p.x *= uniforms.size.x/uniforms.size.y;
    
    return float4(quilt_map(p, a,                    uniforms.time).r,
                  quilt_map(p, a+uniforms.calib.w,   uniforms.time).g,
                  quilt_map(p, a+uniforms.calib.w*2, uniforms.time).b,
                  1.0
                  );
}

